<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Faton Rekathati">
<meta name="dcterms.date" content="2023-03-09">
<meta name="description" content="KBLab releases RixVox, a speech dataset comprised of 5500 hours of speech from parliamentary debates. The speeches have been aligned with transcripts from written protocols, and contain additional metadata such as the speaker’s gender, electoral district and birth year. RixVox is open and free for everyone to download and use.">

<title>RixVox: A Swedish Speech Corpus with 5500 Hours of Speech from Parliamentary Debates – The KBLab Blog</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<link href="../../images/kblab_logo_noprint.png" rel="icon" type="image/png">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-4723c2ce50f655324c098584fc94d321.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="rixvox-a-swedish-speech-corpus_files/pagedtable-1.1/js/pagedtable.js"></script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
<link rel="stylesheet" href="rixvox-a-swedish-speech-corpus_files/pagedtable-1.1/css/pagedtable.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../images/kblab_logo_noprint.png" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">The KBLab Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-models" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Models</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-models">    
        <li>
    <a class="dropdown-item" href="https://huggingface.co/KBLab">
 <span class="dropdown-text">KBLab Hugging Face</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="https://huggingface.co/collections/KBLab/kb-whisper-67af9eafb24da903b63cc4aa">
 <span class="dropdown-text">KB-Whisper</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../cite.html"> 
<span class="menu-text">How to cite</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/kb-labb"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../index.xml"> <i class="bi bi-rss" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">RixVox: A Swedish Speech Corpus with 5500 Hours of Speech from Parliamentary Debates</h1>
                  <div>
        <div class="description">
          <p>KBLab releases RixVox, a speech dataset comprised of 5500 hours of speech from parliamentary debates. The speeches have been aligned with transcripts from written protocols, and contain additional metadata such as the speaker’s gender, electoral district and birth year. RixVox is open and free for everyone to download and use.</p>
        </div>
      </div>
                </div>
  </div>
    
  <div class="quarto-title-meta-author">
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-heading">Affiliation</div>
    
      <div class="quarto-title-meta-contents">
      <p class="author"><a href="https://github.com/Lauler">Faton Rekathati</a> </p>
    </div>
    <div class="quarto-title-meta-contents">
          <p class="affiliation">
              KBLab
            </p>
        </div>
    </div>

  <div class="quarto-title-meta">

        
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">March 9, 2023</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#rixvox-dataset-statistics" id="toc-rixvox-dataset-statistics" class="nav-link active" data-scroll-target="#rixvox-dataset-statistics">RixVox dataset statistics</a>
  <ul class="collapse">
  <li><a href="#most-and-least-intelligible-electoral-districts" id="toc-most-and-least-intelligible-electoral-districts" class="nav-link" data-scroll-target="#most-and-least-intelligible-electoral-districts">Most and least intelligible electoral districts</a></li>
  <li><a href="#longest-total-duration-speaker" id="toc-longest-total-duration-speaker" class="nav-link" data-scroll-target="#longest-total-duration-speaker">Longest total duration speaker</a></li>
  </ul></li>
  <li><a href="#method-of-creation" id="toc-method-of-creation" class="nav-link" data-scroll-target="#method-of-creation">Method of creation</a>
  <ul class="collapse">
  <li><a href="#quality-filtering" id="toc-quality-filtering" class="nav-link" data-scroll-target="#quality-filtering">Quality filtering</a></li>
  <li><a href="#forced-alignment" id="toc-forced-alignment" class="nav-link" data-scroll-target="#forced-alignment">Forced alignment</a></li>
  <li><a href="#creating-30s-observation-snippets." id="toc-creating-30s-observation-snippets." class="nav-link" data-scroll-target="#creating-30s-observation-snippets.">Creating 30s observation snippets.</a></li>
  <li><a href="#dataset-card" id="toc-dataset-card" class="nav-link" data-scroll-target="#dataset-card">Dataset card</a></li>
  </ul></li>
  <li><a href="#acknowledgements" id="toc-acknowledgements" class="nav-link" data-scroll-target="#acknowledgements">Acknowledgements</a></li>
  
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/Lauler/lauler.github.io/blob/main/posts/2023-03-09-rixvox-a-swedish-speech-corpus/index.qmd" target="_blank" class="toc-action"><i class="bi bi-github"></i>View source</a></li><li><a href="https://github.com/Lauler/lauler.github.io/issues/new" target="_blank" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block page-columns page-full" id="quarto-document-content">





<p>Automatic Speech Recognition (ASR) systems that convert spoken language to text rely heavily on annotated data to produce the best possible results. Such datasets are unfortunately not widely available for Swedish. The combined total of currently available audio datasets with annotated transcripts for the Swedish language number somewhere in the hundreds of hours.</p>
<p>To this end, KBLab releases Rixvox, a new Swedish ASR dataset consisting of <span class="math inline">\(5500\)</span> hours of speech. The data originates from parliamentary debates between the years of <span class="math inline">\(2003\)</span> to <span class="math inline">\(2023\)</span>, which were made available via the Swedish Parliament’s open data initiative. KBLab used written protocols to segment speeches from the debates, and to subsequently force align the the written transcripts with audio from the speeches. In addition to audio and transcripts, metadata such as the name, gender, birth year, political party, and electoral district of speakers is also available.</p>
<p>RixVox is free and open for anyone to download and use. The dataset can be reached on the following link: https://huggingface.co/datasets/KBLab/rixvox .</p>
<section id="rixvox-dataset-statistics" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="rixvox-dataset-statistics">RixVox dataset statistics</h2>
<p>The RixVox dataset was constructed from parliamentary debates. You can read more about how we segmented speeches from debates and determined their precise start and end location within a debate in a previous article on this blog: “Finding Speeches in the Riksdag’s debates” <span class="citation" data-cites="rekathati2023finding">(<a href="#ref-rekathati2023finding" role="doc-biblioref">Rekathati 2023</a>)</span>.</p>
<p>The dataset has chunked the audio from speeches in to smaller snippets suitable for training ASR models. Each observation is <em>up to</em> 30 seconds in length, and consists of either a single or several sentences from the written transcript of a speech, along with the corresponding audio. The dataset consists of a total of <span class="math inline">\(5493.6\)</span> hours of speech. There are <span class="math inline">\(1194\)</span> different speakers represented in the data. The average duration of an observation is <span class="math inline">\(23.68\)</span> seconds. In the table below, we present the distribution of observations of the different train, validation and test split of RixVox, along with some summary statistics for each split.</p>
<div class="column-body">
<table class="caption-top table">
<colgroup>
<col style="width: 11%">
<col style="width: 15%">
<col style="width: 28%">
<col style="width: 27%">
<col style="width: 16%">
</colgroup>
<thead>
<tr class="header">
<th>Dataset Split</th>
<th style="text-align: right;">Observations</th>
<th style="text-align: right;">Total duration of speech (hours)</th>
<th style="text-align: right;">Average duration obs. (seconds)</th>
<th style="text-align: right;">Number of speakers</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Train</td>
<td style="text-align: right;">818227</td>
<td style="text-align: right;">5383</td>
<td style="text-align: right;">23.69</td>
<td style="text-align: right;">1165</td>
</tr>
<tr class="even">
<td>Validation</td>
<td style="text-align: right;">7933</td>
<td style="text-align: right;">52</td>
<td style="text-align: right;">23.50</td>
<td style="text-align: right;">18</td>
</tr>
<tr class="odd">
<td>Test</td>
<td style="text-align: right;">8884</td>
<td style="text-align: right;">59</td>
<td style="text-align: right;">23.74</td>
<td style="text-align: right;">11</td>
</tr>
</tbody>
</table>
</div>
<p>The dataset splits were created by sampling speakers until a threshold was reached in terms of total duration of speech. For the training set, we randomly sampled speakers until <span class="math inline">\(98\%\)</span> of the total duration of the RixVox dataset was reached (<span class="math inline">\(5384\)</span> hours). For the test and validation set, we randomly sampled speakers until each filled up to a bucket of <span class="math inline">\(1\%\)</span> of the total duration of the entire dataset.</p>
<p>Let’s also take a look at the gender distribution of speakers. We have <span class="math inline">\(602\)</span> men, <span class="math inline">\(519\)</span> women, and <span class="math inline">\(73\)</span> speakers for whom this metadata is missing.</p>
<div data-pagedtable="false">
<script data-pagedtable-source="" type="application/json">
{"columns":[{"label":["Gender"],"name":[1],"type":["chr"],"align":["left"]},{"label":["Number"],"name":[2],"type":["int"],"align":["right"]}],"data":[{"1":"female","2":"519"},{"1":"male","2":"602"},{"1":"NA","2":"73"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Looking at the total duration of speech for each gender, we have a similar distribution to above. <span class="math inline">\(46.3\%\)</span> of the individual speakers were women, and <span class="math inline">\(44.3\%\)</span> of the total duration of speeches in RixVox is made up of women speaking.</p>
<div class="column-body">
<div data-pagedtable="false">
<script data-pagedtable-source="" type="application/json">
{"columns":[{"label":["Gender"],"name":[1],"type":["chr"],"align":["left"]},{"label":["Total duration (hours)"],"name":[2],"type":["dbl"],"align":["right"]}],"data":[{"1":"female","2":"2361.15"},{"1":"male","2":"2967.57"},{"1":"NA","2":"164.92"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<section id="most-and-least-intelligible-electoral-districts" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="most-and-least-intelligible-electoral-districts">Most and least intelligible electoral districts</h3>
<p>Each observation in our dataset belongs to a speech in a debate. After segmenting the speeches from debate audio files, we machine transcribed every speech using KBLab’s <a href="https://huggingface.co/KBLab/wav2vec2-large-voxrex-swedish">wav2vec2-large-voxrex-swedish</a> model <span class="citation" data-cites="wav2vec2">(<a href="#ref-wav2vec2" role="doc-biblioref">Malmsten, Haffenden, and Börjeson 2022</a>)</span>. We then calculated the <a href="https://en.wikipedia.org/wiki/BLEU">BLEU score</a> to measure the correspondence between the machine generated transcription and the official written transcript. A high BLEU score indicates there’s a higher correspondence, or overlap, between the machine generated transcript and the official transcript. This may indicate that ASR systems find certain regions easier to transcribe, or may alternatively indicate that the people who transcribe the speeches tend to rephrase or reword written transcripts of speeches from these districts.</p>
<div class="column-body-outset">
<div data-pagedtable="false">
<script data-pagedtable-source="" type="application/json">
{"columns":[{"label":["Electoral district"],"name":[1],"type":["chr"],"align":["left"]},{"label":["Mean BLEU score"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["Std. dev. BLEU"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["Number of speakers"],"name":[4],"type":["int"],"align":["right"]}],"data":[{"1":"NA","2":"0.6000797","3":"0.1252977","4":"NA"},{"1":"Jönköpings län","2":"0.5940009","3":"0.1277287","4":"37"},{"1":"Södermanlands län","2":"0.5935326","3":"0.1206110","4":"38"},{"1":"Uppsala län","2":"0.5929714","3":"0.1270916","4":"43"},{"1":"Västra Götalands läns södra","2":"0.5898193","3":"0.1230608","4":"20"},{"1":"Stockholms län","2":"0.5854009","3":"0.1268066","4":"137"},{"1":"Skåne läns norra och östra","2":"0.5853696","3":"0.1305330","4":"32"},{"1":"Jämtlands län","2":"0.5826683","3":"0.1252455","4":"17"},{"1":"Hallands län","2":"0.5820507","3":"0.1225573","4":"38"},{"1":"Kronobergs län","2":"0.5816702","3":"0.1067194","4":"20"},{"1":"Östergötlands län","2":"0.5810539","3":"0.1335815","4":"45"},{"1":"Göteborgs kommun","2":"0.5796593","3":"0.1256837","4":"60"},{"1":"Västra Götalands läns norra","2":"0.5787399","3":"0.1258094","4":"29"},{"1":"Stockholms kommun","2":"0.5767339","3":"0.1243611","4":"126"},{"1":"Västerbottens län","2":"0.5724071","3":"0.1149559","4":"36"},{"1":"Blekinge län","2":"0.5721980","3":"0.1351392","4":"15"},{"1":"Örebro län","2":"0.5699883","3":"0.1232872","4":"33"},{"1":"Kalmar län","2":"0.5664890","3":"0.1302711","4":"28"},{"1":"Skåne läns västra","2":"0.5648055","3":"0.1237373","4":"30"},{"1":"Västmanlands län","2":"0.5628068","3":"0.1415991","4":"30"},{"1":"Norrbottens län","2":"0.5624232","3":"0.1463259","4":"26"},{"1":"Dalarnas län","2":"0.5617315","3":"0.1218160","4":"41"},{"1":"Västra Götalands läns östra","2":"0.5575997","3":"0.1214828","4":"25"},{"1":"Värmlands län","2":"0.5571123","3":"0.1232013","4":"35"},{"1":"Västra Götalands läns västra","2":"0.5566830","3":"0.1549344","4":"38"},{"1":"Västernorrlands län","2":"0.5565349","3":"0.1585068","4":"27"},{"1":"Gävleborgs län","2":"0.5548522","3":"0.1156745","4":"30"},{"1":"Skåne läns södra","2":"0.5393078","3":"0.1289290","4":"49"},{"1":"Gotlands län","2":"0.5383960","3":"0.1534656","4":"7"},{"1":"Malmö kommun","2":"0.5338347","3":"0.1100739","4":"30"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<p>The speakers with the highest score are for those whom thedistrict is missing (<code>NA</code>). These are mostly government ministers who have never been members of parliament. The least intelligible electoral districts are southern Skåne, Gotland, and Malmö municipality (also southern Skåne).</p>
</section>
<section id="longest-total-duration-speaker" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="longest-total-duration-speaker">Longest total duration speaker</h3>
<p>Which speakers have spent the most time on the Riksdag Chamber’s podium? The table below shows that Morgan Johansson is the undisputed <span class="math inline">\(\#1\)</span> debater in terms of total duration of speech.</p>
<div class="column-body-outset">
<div data-pagedtable="false">
<script data-pagedtable-source="" type="application/json">
{"columns":[{"label":["Speaker"],"name":[1],"type":["chr"],"align":["left"]},{"label":["Party"],"name":[2],"type":["chr"],"align":["left"]},{"label":["Total duration (hours)"],"name":[3],"type":["dbl"],"align":["right"]}],"data":[{"1":"Morgan Johansson","2":"S","3":"72.72"},{"1":"Jens Holm","2":"V","3":"61.79"},{"1":"Beatrice Ask","2":"M","3":"48.50"},{"1":"Anders Borg","2":"M","3":"47.91"},{"1":"Mikael Damberg","2":"S","3":"46.83"},{"1":"Tomas Eneroth","2":"S","3":"44.82"},{"1":"Magdalena Andersson","2":"S","3":"39.60"},{"1":"Peter Hultqvist","2":"S","3":"38.23"},{"1":"Per Bolund","2":"MP","3":"33.94"},{"1":"Monica Green","2":"S","3":"32.60"},{"1":"Anders Ygeman","2":"S","3":"31.61"},{"1":"Hillevi Larsson","2":"S","3":"31.57"},{"1":"Lena Hallengren","2":"S","3":"30.92"},{"1":"Göran Hägglund","2":"KD","3":"30.62"},{"1":"Ylva Johansson","2":"S","3":"30.36"},{"1":"Annika Strandhäll","2":"S","3":"29.15"},{"1":"Maud Olofsson","2":"C","3":"27.86"},{"1":"Ibrahim Baylan","2":"S","3":"27.51"},{"1":"Jan Björklund","2":"L","3":"27.14"},{"1":"Eva-Lena Jansson","2":"S","3":"26.82"},{"1":"Lars Tysklind","2":"L","3":"26.79"},{"1":"Sven Otto Littorin","2":"M","3":"26.61"},{"1":"Catharina Elmsäter-Svärd","2":"M","3":"26.59"},{"1":"Maria Larsson","2":"KD","3":"26.59"},{"1":"Roger Haddad","2":"L","3":"25.15"},{"1":"Börje Vestlund","2":"S","3":"24.95"},{"1":"Håkan Svenneling","2":"V","3":"24.10"},{"1":"Ulla Andersson","2":"V","3":"23.87"},{"1":"Jan Lindholm","2":"MP","3":"23.77"},{"1":"Ann Linde","2":"S","3":"23.46"},{"1":"Ola Johansson","2":"C","3":"23.44"},{"1":"Kerstin Lundgren","2":"C","3":"22.89"},{"1":"Gunnar Andrén","2":"L","3":"22.60"},{"1":"Margot Wallström","2":"S","3":"22.55"},{"1":"Patrik Björck","2":"S","3":"22.51"},{"1":"Sven-Erik Bucht","2":"S","3":"22.24"},{"1":"Eskil Erlandsson","2":"C","3":"22.04"},{"1":"Johan Hultberg","2":"M","3":"21.73"},{"1":"Isak From","2":"S","3":"21.68"},{"1":"Karin Rågsjö","2":"V","3":"21.42"},{"1":"Fredrik Malm","2":"L","3":"21.30"},{"1":"Thomas Morell","2":"SD","3":"20.81"},{"1":"Lars Beckman","2":"M","3":"20.57"},{"1":"Anna Johansson","2":"S","3":"20.34"},{"1":"Mats Odell","2":"KD","3":"20.21"},{"1":"Hillevi Engström","2":"M","3":"20.18"},{"1":"Finn Bengtsson","2":"M","3":"19.87"},{"1":"Isabella Lövin","2":"MP","3":"19.44"},{"1":"Nina Lundström","2":"L","3":"19.43"},{"1":"Ali Esbati","2":"V","3":"19.22"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
</section>
</section>
<section id="method-of-creation" class="level2">
<h2 class="anchored" data-anchor-id="method-of-creation">Method of creation</h2>
<p>Before RixVox could be created, we needed to accurately segment speeches from debates. In other words: locate where the speech started and ended within the debate audio file. The most cumbersome parts of the preliminary work undertaken to segment speeches from debates is described in our previous article “Finding Speeches in the Riksdag’s Debates” <span class="citation" data-cites="rekathati2023finding">(<a href="#ref-rekathati2023finding" role="doc-biblioref">Rekathati 2023</a>)</span>. We recommend reading this article for background on the speech segmentation.</p>
<section id="quality-filtering" class="level3">
<h3 class="anchored" data-anchor-id="quality-filtering">Quality filtering</h3>
<p>Once the speeches were segmented, the remaining work consisted of performing some quality filtering based on simple heuristics, aligning the written transcripts with the audio on a sentence level, adding metadata about the speakers, and finally converting the alignments to short snippets up to 30 seconds in length (a suitable format for training ASR models).</p>
<p>The first round of quality filters applied on speeches can be found in the <a href="https://github.com/kb-labb/riksdagen_anforanden/blob/d0f066ed23b66eba55cc01c0b7cb5393db94e914/scripts/heuristic_filter.py#L21-L45">following lines of code</a>. These include:</p>
<ul>
<li>We keep only speeches <span class="math inline">\(&gt; 25\)</span> seconds in duration as predicted by speaker diarization (see the linked article for context). The reliability of our speech segmentation method improves with speech length.</li>
<li>We keep only speeches <span class="math inline">\(&gt; 15\)</span> seconds in duration as predicted by fuzzy string matching between machine transcription and official transcripts.</li>
<li>We calculate a “length ratio”, which is the predicted duration of the speech by speaker diarization, divided by the predicted duration of the speech by fuzzy string matching. We only keep the speech if this length ratio is between <span class="math inline">\(0.8\)</span> and <span class="math inline">\(1.5\)</span>. Otherwise, we deem our two methods to be in too much of a disagreement.</li>
<li>We calculate an “overlap ratio”, which is the “duration where speaker diarization and fuzzy string matching predictions overlap” divided by the total predicted duration of the fuzzy string matching method. If this ratio is <span class="math inline">\(&gt;0.8\)</span> we keep the speech.</li>
<li>We only keep speeches where <span class="math inline">\(1\)</span> single speaker was identified as speaking within the predicted regions.</li>
<li>We only keep speeches where the difference in predicted start time between a future and previous speech is <span class="math inline">\(&gt;5\)</span> seconds.</li>
</ul>
<p>The second round of quality filters were applied after another fuzzy string matching sanity check was performed. This time, instead of fuzzy string matching the text of a written transcript against the machine transcription of an entire debate, we fuzzy string match the text of the written transcript against the machine transcription of the segmented speech, as predicted by our speaker diarization. A short summary of the second round of quality filters follows:</p>
<ul>
<li>Removing speeches where the official written protocol starts matching the machine transcription only after a threshold of <span class="math inline">\(X\)</span> words in the machine transcribed version. This was a possible indication that the speech segmentation had predicted a <strong>too early</strong> start location for the speech, erroneously including parts of other speakers.<br>
</li>
<li>Removing speeches where the official written protocol stops matching hte machine transcription too early.</li>
<li>We adjust the <span class="math inline">\(X\)</span> threshold based on different dates the debates were held on, and whether the debate was the first and/or the last speech of the debate (the first and last speeches of debates were more likely to be cut off in the middle of the speech before the year <span class="math inline">\(2012\)</span>).</li>
</ul>
<p>See the <a href="https://github.com/kb-labb/riksdagen_anforanden/blob/d0f066ed23b66eba55cc01c0b7cb5393db94e914/scripts/rixvox_filter.py#L28-L51">following lines of code</a> for a full list of the filtering conditions.</p>
<p>The above filtering procedures reduced the number of speeches to be included in RixVox from about 122k speeches to 115k speeches.</p>
</section>
<section id="forced-alignment" class="level3">
<h3 class="anchored" data-anchor-id="forced-alignment">Forced alignment</h3>
<p>Once we had high confidence in the remaining set of predictions, we proceeded to align the written protocols with the audio. This was done by:</p>
<ol type="1">
<li>Sentence tokenizing the written transcripts.</li>
<li>Using the <a href="https://www.readbeyond.it/aeneas/"><code>aeneas</code> library</a> to force align the audio with the text on the sentence level.</li>
</ol>
<p>The <code>aeneas</code> library gives an output in the form of predicing the <code>start</code> and <code>end</code> location of the sentence within the speech.</p>
<p>We can recommend reading the masters thesis <strong>“Automatic Annotation of Speech: Exploring Boundaries within Forced Alignment for Swedish and Norwegian”</strong> <span class="citation" data-cites="Biczysko1674281">(<a href="#ref-Biczysko1674281" role="doc-biblioref">Biczysko 2022</a>)</span> for an excellent review of available forced alignment tools for Swedish and Norwegian.</p>
</section>
<section id="creating-30s-observation-snippets." class="level3">
<h3 class="anchored" data-anchor-id="creating-30s-observation-snippets.">Creating 30s observation snippets.</h3>
<p>In the final step, we concatenate sentences from the same speech that follow one another up to a maximum length of <span class="math inline">\(30\)</span> seconds per observation. The observations in RixVox are thus composed of either a single sentence, or several sentences in order within a speech up until the “bucket” fills up to the threshold of <span class="math inline">\(30\)</span> seconds.</p>
<p>We remove the first sentence of each speech, as transcriptions tend to add a “Fru talman!” or “Herr Talman” here as a matter of formality, regardless of whether this was uttered by the speaker or not.</p>
</section>
<section id="dataset-card" class="level3">
<h3 class="anchored" data-anchor-id="dataset-card">Dataset card</h3>
<p>RixVox has <a href="https://huggingface.co/datasets/KBLab/rixvox">a dataset card</a> on Huggingface, where you can find more details about the dataset, its features, and how to download and use it. You can also preview the first 100 observations of the train, validation and test sets in <a href="https://huggingface.co/datasets/KBLab/rixvox/viewer/default/train">the dataset viewer</a>.</p>
</section>
</section>
<section id="acknowledgements" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="acknowledgements">Acknowledgements</h2>
<p>Part of this development work was carried out within the frame of the infrastructural project <a href="https://www.huminfra.se/">HUMINFRA</a>.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p><img src="../2023-02-15-finding-speeches-in-the-riksdags-debates/huminfra.svg" class="img-fluid" style="width:35.0%"></p>
</div></div></section>


<div id="quarto-appendix" class="default"><section id="code" class="level2 appendix"><h2 class="anchored quarto-appendix-heading">Code</h2><div class="quarto-appendix-contents">

<p>The code for reproducing results in this article can be found on https://github.com/kb-labb/riksdagen_anforanden.</p>



</div></section><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-Biczysko1674281" class="csl-entry" role="listitem">
Biczysko, Klaudia. 2022. <span>“Automatic Annotation of Speech: Exploring Boundaries Within Forced Alignment for Swedish and Norwegian.”</span> Master’s thesis, Uppsala University, Department of Linguistics; Philology; Uppsala University, Department of Linguistics; Philology.
</div>
<div id="ref-wav2vec2" class="csl-entry" role="listitem">
Malmsten, Martin, Chris Haffenden, and Love Börjeson. 2022. <span>“Hearing Voices at the National Library – a Speech Corpus and Acoustic Model for the Swedish Language.”</span> <a href="https://arxiv.org/abs/2205.03026">https://arxiv.org/abs/2205.03026</a>.
</div>
<div id="ref-rekathati2023finding" class="csl-entry" role="listitem">
Rekathati, Faton. 2023. <span>“The KBLab Blog: Finding Speeches in the Riksdag’s Debates.”</span> <a href="https://kb-labb.github.io/posts/2023-02-15-finding-speeches-in-the-riksdags-debates/">https://kb-labb.github.io/posts/2023-02-15-finding-speeches-in-the-riksdags-debates/</a>.
</div>
</div></section><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@online{rekathati2023,
  author = {Rekathati, Faton},
  title = {RixVox: {A} {Swedish} {Speech} {Corpus} with 5500 {Hours} of
    {Speech} from {Parliamentary} {Debates}},
  date = {2023-03-09},
  url = {https://kb-labb.github.io/posts/2023-03-09-rixvox-a-swedish-speech-corpus/},
  langid = {en}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-rekathati2023" class="csl-entry quarto-appendix-citeas" role="listitem">
Rekathati, Faton. 2023. <span>“RixVox: A Swedish Speech Corpus with 5500
Hours of Speech from Parliamentary Debates.”</span> March 9, 2023. <a href="https://kb-labb.github.io/posts/2023-03-09-rixvox-a-swedish-speech-corpus/">https://kb-labb.github.io/posts/2023-03-09-rixvox-a-swedish-speech-corpus/</a>.
</div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/kb-labb\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../../images/kb_logo_text_black.png" class="img-fluid figure-img" style="width:30.0%"></p>
<figcaption>Contact: <a href="mailto:kblabb@kb.se">kblabb@kb.se</a></figcaption>
</figure>
</div>
<div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/Lauler/lauler.github.io/blob/main/posts/2023-03-09-rixvox-a-swedish-speech-corpus/index.qmd" target="_blank" class="toc-action"><i class="bi bi-github"></i>View source</a></li><li><a href="https://github.com/Lauler/lauler.github.io/issues/new" target="_blank" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>